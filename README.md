# Мессенджер

Задания практикума -- мессенджер, состоящий из двух приложений: клиентского и серверного.

Запуск приложения-сервера:
```
python3 server.py <ip> <port>
```

Запуск приложения-клиента:
```
python3 client.py <ip> <port>
```

## Сервер
Сервер должен работать на уровне TCP. Вам потребуется библиотека `socket`. Сервер должен иметь возможность подключить до 1000 клиентов. На тройку достаточно будет реализовать известный нам чат-помойку с одним дополнением: аутентификация. Напомню, о чем идет речь: сервер, получая сообщение от клиента печатает на экран ник этого клиента, время сообщения и текст самого сообщения, после чего рассылает эту строку всем клиентам за исключением отправителя. Пример:
```
gigalol (23:56): Hello, World!
```
К известной нам структуре добавился ник и аутентификация. Это означает, что при подключении к серверу, он просит клиента представиться и ищет клиента в базе по нику. Если ник обнаружен, клиента просят ввести пароль, далее происходит процедура сверки паролей, если они не совпадают, клиента отключает от сервера, если же все в порядке, клиенту сообщается об успешной аутентификации, он может приступать к общению. Важно! Ни в коем случае нельзя хранить пароль клиента, следует взять от него хэш, например, `sha1` и сверять хэши паролей. Хранение паролей в открытом виде -- фу-фу-фу! Если это первое подключение клиента к серверу и его ник не обнаружен, сервер дважды просит его ввести пароль, сверяя результаты, затем сохраняет хэш этого пароля, чтобы аутентифицировать клиента в будущем. Важно, что сервер не должен "зависать" в процессе общения с клиентом и "кидать" всех остальных пользователей. Он должен "запоминать", в каком статусе находится тот или иной клиент и постоянно продолжать обслуживание всех в штатном режиме. Напомню, что параллельное обслуживание нескольких сокетов позволит реализовать библиотека `selectors`.

## Клиент
У клиентсокго приложения две функции: печатать все, что приходит от сервера и отправлять на сервер все, что приходит с клавиатуры. А чтобы эти функции реализовывать параллельно, не прибегая к активному ожиданию, следует также воспользоваться библиотекой `selectors`.

## Команды
Введем такое понятие как команда. Команды будут начинаться с символа `/`. И введем следующий список команд:
- `/create <name>` -- команда создает комнату на сервере с названием `<name>`. Если имя занято, сервер должен об этом сообщить, если же имя свободно. сервер должен создать комнату и сообщить ее создателю пароль от комнаты.
- `/join <name> <password>` -- команда, позволяющая клиенту войти в комнату, используя пароль, который сервер выдал создателю данной комнаты. Создатель комнаты входит в нее автоматически при создании. При этом клиент как бы покидает основной чат: теперь его сообщения будут видеть только члены комнаты, он также будет видить только сообщения членов комнаты. Как и в случае с аутентификацией клиентов, не следует хранить пароли от комнат в открытом виде, храните хэши.
- `/exit` -- команда, позволяющая покинуть комнату и вернуться в общий чат.

## Сохранение данных
При остановке сервера (неважно, плановой или аварийной), все данные будут утеряны. Требуется научить сервер сохранять все данные при его штатной остановке. Штатной будем называть остановку в результате получения сигнала `SIGINT` (приложение получает его, когда мы нажимаем `Ctrl+c`). Перед остановкой сервер должен сохранить все данные в файл. А при следующем старте сервер должен импортировать данные из файла. Справиться с этим поможет библиотека `signal`.
